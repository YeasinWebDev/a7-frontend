import Link from "next/link";
import React from "react";
import BlogCard from "../common/BlogCard";

function Blogs() {
  return (
    <section className="max-w-7xl mx-auto md:px-6 py-16 text-center md:text-left flex flex-col items-start">
      <h2 className="text-2xl md:text-4xl font-bold text-center w-full mb-5">My Blog Postsüìù</h2>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3 pt-5">
        {blogs.slice(0, 3).map((blog) => (
          <BlogCard key={blog.id} blog={blog} />
        ))}
      </div>
      <Link href="/blogs" className="flex items-center justify-center mt-5 w-full">
        <button className="border-b border-gray-500 hover:border-gray-300 p-2 hover:text-gray-300 hover:scale-105 transition-all cursor-pointer">View All</button>
      </Link>
    </section>
  );
}

export default Blogs;

const blogs = [
  {
    id: 1,
    title: "Mastering React Hooks",
    image:
      "https://media.licdn.com/dms/image/v2/D5612AQEnL4bsGds2hw/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1710164295789?e=2147483647&v=beta&t=AgKKilmSSbcd2v1mfZEHl3ugrsgGTssXHUKCp6seGQg",
    excerpt: "Hooks like useState, useEffect, and useContext make React development easier and more powerful. Learn how to leverage them in your projects.",
    content:
      "React Hooks have transformed the way developers build applications with React. Before hooks were introduced in React 16.8, developers had to rely on class components to manage state, lifecycle methods, and context. This often resulted in verbose code and complex patterns that were difficult to scale. With hooks, React introduced a more functional and modular way to manage state and side effects.\n\nThe most commonly used hook is useState, which allows you to manage component-level state without writing a class. For example, a counter component can be written in just a few lines using useState, making it easier to read and maintain. Another essential hook is useEffect, which lets you handle side effects such as data fetching, subscriptions, or manually updating the DOM. Instead of scattering lifecycle logic across multiple class methods like componentDidMount or componentWillUnmount, you can centralize related logic inside a single useEffect call.\n\nContext management also became simpler with the useContext hook. Instead of relying on higher-order components or complex render props, you can now consume context values directly inside functional components. This has improved the developer experience and made React codebases more predictable.\n\nBeyond these basics, React also provides advanced hooks like useReducer for state logic that requires multiple actions, and useMemo and useCallback for performance optimization. These hooks help prevent unnecessary re-renders and keep applications responsive, even when handling complex UI interactions.\n\nOne of the most powerful aspects of hooks is the ability to create custom hooks. A custom hook is essentially a reusable piece of stateful logic that you can share across multiple components. For example, you could create a useFetch hook that encapsulates data fetching logic, making your code more modular and reducing repetition.\n\nAs React applications scale, understanding how to combine these hooks effectively becomes essential. For instance, you might use useReducer for complex state management, useEffect for API calls, and custom hooks to abstract repeated patterns. This modularity improves maintainability and encourages clean separation of concerns.\n\nIn conclusion, React Hooks are more than just a syntactic improvement‚Äîthey represent a shift towards functional programming and composability in React. By mastering hooks like useState, useEffect, and useContext, along with advanced patterns like custom hooks, you can write cleaner, more efficient, and more reusable code. As the React ecosystem continues to evolve, hooks remain at the core of modern frontend development, making them an indispensable tool for any developer.",
  },
  {
    id: 2,
    title: "Why Tailwind CSS is a Game Changer",
    image:
      "https://media.licdn.com/dms/image/v2/D5612AQHLA3mTYlge6Q/article-cover_image-shrink_720_1280/B56ZUoReccHQAQ-/0/1740137430072?e=2147483647&v=beta&t=AjOYy-3ONhMxmIjlrGSdMwvav7fccw2552Jmn_8xOEQ",
    excerpt: "Tailwind CSS provides utility-first classes that speed up styling. Here‚Äôs why I use it in almost all of my frontend projects.",
    content:
      "Tailwind CSS has rapidly become one of the most popular frameworks in frontend development, and for good reason. Unlike traditional CSS frameworks like Bootstrap or Foundation, which rely heavily on pre-styled components, Tailwind takes a utility-first approach. This means instead of writing custom CSS rules or overriding default styles, developers compose UI elements using utility classes directly in their markup.\n\nOne of the biggest advantages of Tailwind is speed. When working on a project, instead of bouncing back and forth between your HTML and CSS files, you can design directly in your JSX or HTML with classes like bg-blue-500, text-center, or p-4. This approach reduces context switching, speeds up prototyping, and helps developers move from idea to implementation much faster.\n\nAnother strength of Tailwind is consistency. Because utility classes follow a design system, you avoid issues like inconsistent font sizes, colors, or spacing across your project. Tailwind enforces a design scale, which makes it easier to maintain a cohesive look and feel throughout the application. This is particularly useful for teams working on large-scale projects where multiple developers contribute to the same codebase.\n\nResponsive design is another area where Tailwind shines. It provides built-in responsive variants like md:, lg:, and xl:, allowing you to create fully responsive layouts with minimal effort. Instead of writing custom media queries, you can apply responsive utility classes directly to your elements. This makes mobile-first development seamless and reduces the need for bloated CSS files.\n\nCustomization is also straightforward. Tailwind‚Äôs configuration file allows you to define your own color palette, spacing scale, and typography settings. This gives developers complete control over the design system while still benefiting from the utility-first workflow. You can even extend Tailwind with plugins to add animations, gradients, or custom utilities.\n\nCritics often argue that utility-first CSS makes your markup look cluttered. While it‚Äôs true that elements can have many classes, this approach eliminates the need for maintaining large CSS files with selectors that may become unused over time. Tools like PurgeCSS (integrated with Tailwind) automatically remove unused classes in production builds, ensuring your final CSS file remains small and optimized.\n\nTailwind also integrates well with component-based frameworks like React and Next.js. You can create reusable components styled with utility classes, ensuring consistency and reducing the need for additional CSS files. For example, buttons, cards, and modals can all be composed with Tailwind classes, giving you both flexibility and speed.\n\nIn conclusion, Tailwind CSS is more than just a styling framework‚Äîit‚Äôs a new way of thinking about CSS. Its utility-first approach accelerates development, enforces consistency, and simplifies responsive design. For frontend developers aiming to move fast while maintaining quality, Tailwind has proven to be a true game changer.",
  },
  {
    id: 3,
    title: "Next.js for Frontend Developers",
    image: "https://images.prismic.io//intuzwebsite/4fadf81b-546a-4075-87de-549d1e72cf1f_Banner.png?w=2400&q=80&auto=format,compress&fm=png8",
    excerpt: "Next.js makes React development faster with SSR, SSG, and API routes. Discover how it can improve your workflow.",
    content:
      "Next.js has quickly established itself as the go-to framework for building production-grade React applications. Developed by Vercel, it extends React with powerful features like server-side rendering (SSR), static site generation (SSG), file-based routing, and built-in API routes. For frontend developers, this means faster performance, better SEO, and a smoother developer experience.\n\nOne of the key advantages of Next.js is its approach to rendering. By default, React applications are client-side rendered, meaning the browser has to load JavaScript before rendering the UI. This can lead to slower initial load times and poor SEO performance since search engine crawlers may not fully index JavaScript-heavy pages. Next.js solves this problem with SSR and SSG. SSR renders the page on the server for every request, ensuring that users and crawlers receive a fully rendered HTML page. SSG, on the other hand, generates static HTML at build time, which is perfect for blogs, documentation, and marketing sites.\n\nRouting in Next.js is file-based, meaning you don‚Äôt need to install or configure a routing library. Any file placed inside the pages directory automatically becomes a route. Dynamic routes are also supported, allowing you to build applications like blogs or e-commerce stores with ease. This simplicity saves time and reduces boilerplate code compared to setting up a router manually.\n\nNext.js also comes with API routes, which allow you to create backend endpoints directly within your frontend project. This is particularly useful for small to medium-sized projects where setting up a separate backend might be overkill. You can handle form submissions, authentication, or database queries without leaving your Next.js application.\n\nPerformance optimization is another area where Next.js excels. Features like image optimization, automatic code splitting, and built-in support for lazy loading help improve user experience by reducing load times. The framework also supports Incremental Static Regeneration (ISR), which allows you to update static pages after deployment without rebuilding the entire site.\n\nFrom a developer‚Äôs perspective, Next.js integrates seamlessly with modern tools. It works well with TypeScript, Tailwind CSS, and Redux, making it easy to build scalable applications. Additionally, deployment is streamlined with Vercel, where you can push your code to GitHub and have it live in seconds with automatic builds and previews.\n\nNext.js is not only about performance‚Äîit‚Äôs also about developer experience. Features like hot reloading, API mocking, and zero-config setup make development faster and less frustrating. The learning curve is minimal if you‚Äôre already familiar with React, and the documentation is thorough and beginner-friendly.\n\nIn conclusion, Next.js empowers frontend developers to build high-performance, SEO-friendly, and scalable applications with less effort. Whether you‚Äôre building a personal blog, a SaaS product, or a large-scale e-commerce platform, Next.js provides the tools you need to succeed. Its combination of SSR, SSG, and modern development features make it an essential framework in the React ecosystem.",
  },
  {
    id: 4,
    title: "State Management with Redux Toolkit",
    image:
      "https://media.licdn.com/dms/image/v2/D4D12AQGrcBjhumFxmA/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1724327388492?e=2147483647&v=beta&t=sH_tWKoS-PXePhL6qhui3V-5Q03VRz7Z4HMJB2qA2uI",
    excerpt: "Managing complex states in large applications is much easier with Redux Toolkit. Let‚Äôs dive into its features.",
    content:
      "State management is one of the most critical challenges in frontend development. As applications grow in complexity, managing state across multiple components becomes increasingly difficult. Redux has long been the go-to solution for predictable state management, but its verbose setup and boilerplate code often discouraged developers. This is where Redux Toolkit comes in, offering a simplified and more efficient way to work with Redux.\n\nRedux Toolkit is the official, recommended way to write Redux logic. It provides utilities that streamline the process of creating reducers, actions, and middleware, significantly reducing boilerplate. One of the most important functions it introduces is createSlice, which allows you to define the state structure, reducers, and actions in a single place. This improves readability and maintainability, especially for large applications.\n\nAnother powerful feature is createAsyncThunk, designed for handling asynchronous logic like API calls. Instead of manually writing action types and reducers for loading, success, and error states, createAsyncThunk generates them for you. This simplifies the process of handling async operations while keeping your code clean and predictable.\n\nRedux Toolkit also integrates well with Immer, a library that allows you to write immutable state updates using a mutable style. This means you can write reducers as if you were directly modifying the state, but under the hood, Immer ensures immutability. This reduces the chances of bugs while making reducers easier to understand.\n\nOne of the criticisms of Redux has always been its steep learning curve. Redux Toolkit addresses this by providing sensible defaults and best practices out of the box. For example, it sets up the store with good defaults like Redux DevTools integration and middleware for handling async actions. This allows developers to focus on application logic rather than boilerplate setup.\n\nWhen combined with React hooks like useSelector and useDispatch, Redux Toolkit becomes even more powerful. Components can easily access and update the global state without unnecessary re-renders. This leads to better performance and a cleaner component structure.\n\nRedux Toolkit is also highly scalable. Whether you‚Äôre working on a small project or a large enterprise application, it provides patterns that scale well. The modular nature of slices makes it easy to add new features without touching unrelated parts of the codebase.\n\nIn conclusion, Redux Toolkit has modernized the way developers approach state management in React applications. By reducing boilerplate, simplifying async logic, and enforcing best practices, it makes Redux more approachable and enjoyable to use. For any frontend developer dealing with complex state, Redux Toolkit is a must-have tool in the toolbox.",
  },
];
